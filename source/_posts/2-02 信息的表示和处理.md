---
title: 第二章：信息的表示和处理
categories: [读书笔记,深入理解计算机系统]
tags: [CSAPP,程序结构和执行]
toc: true
mathjax: true
---

### 前言

　　计算机将信息编码为位（bit），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时会使用不同的约定。
　　`大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码`。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。`C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误`。
　　由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于0.0，从而转换成零时，也会下溢。无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，`用(x<<3)-x取代表达式7*x时`，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2的幂之间的关系。`对于浮点运算，我们必须要非常小心地使用，因为浮点运算只有有限的范围和精度，而且并不遵循普通的算术属性，比如结合性。`
<!--more-->

　　在本章节中，我们研究三种最重要的数字表示：

* 无符号编码：基于传统的二进制表示法，表示大于或者等于零的数字。
* 补码编码：该编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。
* 浮点数编码：该编码是表示实数的科学记数法的以2为基数的版本。

### 信息存储

　　大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。`C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址`。

#### 字数据大小

　　每台计算机都有一个字长（word size），指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以`字长决定的最重要的系统参数就是虚拟地址空间的最大大小`。也就是说，对于一个字长为$w$位的机器而言，虚拟地址的范围为 0~$2^w-1$，程序最多访问$2^w$个字节。例如，常见的32位计算机（即$w=32$），其字长限制虚拟地址空间为4千兆字节（4GB）。
　　C语言中的数据类型char表示一个单独的字节。尽管“char”是由于它被用来存储文本串中单个字符这一事实而得名，但它也能被用来存储整数数值。数据类型short、int和long可以提供各种数据大小。`即使是为64位系统编译，数据类型int通常也只有4个字节，数据类型long一般在32位程序中为4字节，在64位程序中则为8字节`。
　　为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。`其中就有数据类型int32_t和int64_t，它们分别为4字节和8字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径`。

#### 寻址和字节顺序

　　为了对于跨域多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。`在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中的最小地址`。例如，假设一个类型为int的变量a的地址为0x100，也就是说，地址表达式&a的值为0x100。那么，（假设数据类型int为32位表示）a的4个字节将被存储在内存的0x100、0x101、0x102和0x103位置。
　　某些机器选择在内存中按照从最低字节的顺序存储，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则——最低有效字节在最前面的方式，称为小端法，后一种规则——最高有效字节在最前面的方式，称为大端法。假设变量a的类型为int，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：

　　　　　　　　　　　　<img src="https://hexo-blog-1258021165.cos.ap-guangzhou.myqcloud.com/02%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/02/01.png" width=60% height=60%>

　　　　　　　　　　　　　　　　　　　　　　　　　　图1：大端法和小端法

　　注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67。`一旦选择了特定操作系统，那么字节顺序也就固定下来了`。
　　对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的，无论哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题：

* 一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现字里	的字节成了反序的。
*  第二种情况是，当阅读表示整数数据的字节序列时，字节顺序也很重要，这通常发生在检查机器级程序时。
*  字节顺序变得重要的第三种情况是，当编写规避正常的类型系统的程序时，在C语言中，可以通过使用强制类型转换（cast）或联合（union）来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。`大多数应用程序都强烈不推荐这种编程技巧，但是它们对系统级编程来说是非常有用的，甚至是必需的`。

#### 表示字符串

　　`C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组`。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。因此，如果我们以参数“12345”和6（包括终止符）来运行show_bytes，我们得到结果31 32 33 34 35 00。请注意，十进制数字a的ASCII码正好是0x3a，为终止字节的十六进制表示为0x00。`在使用ASCII码作为字符码的任何系统上都将得到同样的结果，与字节顺序和字节大小规则无关`。因而，**文本数据比二进制数据具有更强的平台独立性**。

#### C语言中的位级运算

　　C语言的一个很有用的特性就是它支持布尔运算。事实上，我们在布尔运算中使用的那些符号就是C语言所使用的：“|”就是OR（或）“&”就是AND（与）“~”就是NOT（取反），而“^”就是EXCLUSIVE-OR（异或）。这些运算能运用到任何“整型”的数据类型上。`确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制`。

#### C语言中的逻辑运算

　　C语言还提供了一组逻辑运算符“||”、“&&”和“!”，分别对应于命题逻辑中的OR、AND和NOT运算。逻辑运算很容易和位级运算搞混，但是它们的功能地完全不同的。逻辑运算符认为所有非零的参数都表示TRUE，而参数0表示FALSE，它们返回1或者0，分别表示结果为TRUE和FALSE。
　　逻辑运算符“&&”和“||”与它们对应的位级运算“&”和“|”之间的一个重要的区别是，`如果对一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值`。因此，`例如表达式a&&5/a将不会被造成被零除，而表达式p&&*p++也不会导致间接引用空指针`。

#### C语言中的移位运算

　　C语言还提供了一组移位运算，向左或者向右移动位模式。对于左移运算，a<<k表示a向左移动k位，丢弃最高的k位，并在右端补k个0。而对于右移运算，其行为则有点微妙。一般而言，机器支持两种形式的右移：逻辑右移和算术右移。`逻辑右移在左端补k个0，而算术右移是在左端补k个最高有效位的值。几乎所有的编译器/机器组合都有对有符号数使用算术右移`，且许多程序员也都假设机器会使用这种右移。另一方面，`对于无符号数，右移必须是逻辑的`。

### 整数表示

#### 整型数据类型

　　C语言支持多种整型数据类型——表示有限范围的整数。根据字节分配，不同的大小所能表示的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符long的。大多数64位机器使用的8个字节的表示，比32位机器上使用的4个字节的表示的取值范围大很多。

　　　　　　<img src="https://hexo-blog-1258021165.cos.ap-guangzhou.myqcloud.com/02%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/02/02.png" width=80% height=80%>

　　　　　　　　　　　　　　　　　　图2：32位程序和64位程序上整型数据类型的取值范围

　　图2中一个很值得注意的特点是取值范围不是对称的——`负数的范围比整数的范围大1`。

#### 补码编码

　　对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补码形式。在这个定义中，将字的最高有效位解释为负权（也称为符号位）。符号位被设置为1时，表示值为负，而当设置为0时，值为非负的。对于补码也就是有符号整数，其范围是不对称的：$|T_{Min}|=|T_{Max}|+1$，也就是说，$T_{Min}$没有与之对应的正数。之所以会有这样的不对称性，是因为一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位设置为0的数）表示非负数。因为0是非负数，也就意味着，能表示的正数比负数少一个。还有一点就是，最大的无符号数值刚好比补码的最大值的两倍大一点：$U_{Max}=2T_{Max}+1$。
　　C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，除了规定的有符号数值的范围之外，我们不应该假设任何可表示的数值范围，也不应该假设有符号数会使用何种特殊的表达方式。

#### 有符号数和无符号数之间的转换

　　C语言允许在各种不同的数字数据类型之间做强制类型转换，但是，`将负数转换成无符号数可能会得到0`。而且`如果转换的无符号数太大以至于超出了补码能够表示的范围`，可能会得到$T_{Max}$。不过，对于大多数C语言的实现来说，`对这个问题的回答都是从位级角度来看的，而不是数的角度`。
　　对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：**数值可能会改变，但是位模式不变**。考虑无符号与补码表示之间互相转换的结果，有如下结论：

* 对于在范围$0<=x<=T_{Max}$之内的值x而言，其有相同的无符号和补码表示；
* 对于这个范围之外的数值，转换需要加上或者减去$2^w$。

#### C语言中的有符号数和无符号数

　　C语言允许无符号数和有符号数之间的转换。虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的**原则是底层的位表示保持不变**。但是，`当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算`。有符号数到无符号数的隐式转换，会导致错误或者漏洞，而避免这类错误的一种方法就是绝不使用无符号数。
　　实际上，除了C以外很少有语言支持无符号整数。很明显，由于无符号运算的一些细微特性，这些语言的设计者认为它们带来的麻烦要比益处多得多。比如，Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符>>被定义为执行算术右移。特殊的运算符>>>被定义为执行逻辑右移。
　　`当我们想要把字仅仅看做是位的集合而没有任何数字意义的时候，无符号数值是非常有用的`。例如，往一个字中放入描述各种布尔条件的标记时，就是这样。地址自然地就是无符号的，所以系统级程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。

### 整数运算

　　许多刚入门的程序员非常惊奇地发现，`两个正数相加会得出一个负数，而比较表达式 x<y 和比较表达式 x-y<0 会产生不同的结果`。这些属性是由于计算机运算的有限性造成的，理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。比如，许多程序员调用分配函数（如malloc）时，会使用算术表达式作为参数，并且不对这些表达式进行溢出检查，从而导致问题出现。

#### 无符号加法

　　考虑两个非负整数x和y，满足$ 0<=x, y<2^w$，每个数都能表示为$w$位无符号数字。然而，如果计算它们的和，我们就有一个可能的范围$ 0<=x+y<=2^(w+1)-2$，表示这个可能需要$w+1$位。这个时候就会很可能发生算术运算溢出，`即完整的整数结果不能放到数据类型的字长限制中去`。
　　`当执行C程序时，不会将溢出作为错误而发信号`，不过有时候，我们可能希望判定是否发生了溢出。检测无符号数加法中的溢出，我们有如下方法：对在范围在$ 0<=x, y<=U_{Max_w}$中的x和y，令 s=x+y，当且仅当s<x（或者等价地s<y）时，发生了溢出。解释：通过观察发现 x+y>=x，因此如果s没有溢出，我们能够肯定 s>=x，另一方面，如果s确实溢出了，我们就有 $s=x+y-2^w$。假设$ y<2^w$，我们就有$ y-2^w<0$，因此s<x。

#### 补码加法

　　对于补码加法，我们必须确定当结果太大（为正）或者太小（为负）时，应该做些什么。给定在范围$ -2^{w-1}<=x, y<=2^{w-1}-1 $之内的数值x和y，它们的和就在范围$ -2^w<= x+y<=2^{w-2}$ 之内，要想准确表示，可能需要$w+1$位。
　　两个数的$w$位补码之和与无符号之和有完全相同的位级表示，实际上，大多数计算机使用相同的机器指令来执行无符号或者有符号加法。因此，`对于补码加法的运算，我们可以将其参数转换为无符号数，执行无符号数加法，再将结果转换为补码`：$x+y=U2T_w(T2U_w(x)+T2U_w(y))=U2T_w((x+y) mod 2^w)$。检测补码加法中的溢出，我们有如下方法：对满足 $T_{Min_w}<=x, y<=T_{Max_w }$的x和y，令s=x+y。当且仅当 x>0, y>0，但s<=0时，计算s发生了正溢出。当且仅当 x<0, y<0，但s>=0时，计算s发生了负溢出。

#### 乘以常数

　　以往，`在大多数机器上，整数乘法指令相当慢，需要10个或者更多的时钟周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期`。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。首先，我们会考虑乘以2的幂的情况，然后再概括成以任意常数，比如，左移一个数值等价于执行一个与2的幂相乘的无符号乘法。需要注意的是，无论是无符号运算还是补码运算，乘以2的幂都可能会导致溢出。结果表明，即使溢出的时候，我们通过移位得到的结果也是一样的。并且，大多数编译器只在需要少量移位、加法和减法就足够的时候才会使用这种优化。

#### 除以2的幂

　　在大多数机器上，`整数除法要比整数乘法更慢——需要30个或者更多的始终周期`。除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。`无符号和补码数分别使用逻辑移位和算术移位来达到目的`。

#### 关于整数运算的最后思考

　　正如我们看到的，计算机执行的“整数”运算实际上是一种模运算形式，表示数字的有限字长限制了可能的取值范围，结果运算可能溢出。我们还看到，补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。