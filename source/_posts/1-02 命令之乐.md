---
title: 第二章：命令之乐
categories: [读书笔记,Linux shell脚本攻略]
tags: [shell]
toc: true
---

### 用cat进行拼接

　　cat是命令行通常用于读取、显示或拼接文件内容。用一行命令将目标输入以及文件的数据给组合起来，通常的做法是将stdin重定向到一个文件，然后再将两个文件组合到一起，不过我们可以使用cat命令一次性搞定。

<!--more-->

#### 实战演练

- 打印单个文件的内容：

  ```shell
   $ cat file.txt
   This is a line inside file.txt
  ```

- 打印多个文件的内容：

  ```shell
   $ cat one.txt two.txt
   This is line from one.txt
   This is line feom two.txt
  ```

- cat命令不仅可以读取文件、拼接数据，还能够从标准输入中进行读取，类似地，我们可以用cat将来自输入文件的内容与标准输入拼接在一起，将stdin和另一个文件中的数据结合起来：

  ```shell
   $ echo ‘Text through stdin’ | cat **-** file.txt
   在上面的代码中，**-**被作为stdin文本的文件名。
  ```

- 有时候文本文件中可能包含多处连续的空白行。如果你需要删除这些额外的空白行，使用下面的方法：

  ```shell
   $ cat -s file.txt
  ```

- cat还有一个特性，就是可以将制表符着重标记出来，该特性对排除缩进错误非常有用。用cat命令的-T选项能够将制表符标记成^I：

  ```shell
   $ cat file.py
   def function():
     var = 5
       next = 6
     third = 7
   $ cat -T file.py
   def function():
   ^Ivar = 5
       next = 6
   ^Ithird = 7^I
  ```

- 使用cat命令的-n选项会在输出的每一行内容之前加上行号：

  ```shell
   $ cat -n lines.txt
   1 line
   2 line
  ```

### find命令：文件查找与文件列表

　　find命令的工作方式如下：沿着文件层次结构向下遍历，匹配符合条件的文件，执行相应的操作。

#### 实战演练

- 要列出当前目录及子目录下所有的文件和文件夹，可以采用下面的写法：

  ```shell
   $ find base_path # base_path可以放在任意位置，find会从该位置开始向下查找。例如：
   $ find . -print  # -print指明打印出匹配文件的文件名（路径）
  ```


   当使用-print时，默认’\n’作为用于对输出的文件名进行分隔。-print0指明使用’\0’作为匹配的文件名之间的定界符。当文件名中包含换行符时，这个方法就有用武之地了。

- 根据文件名或正则表达式进行搜索，选项-name的参数指定了文件名所必须匹配的字符串：

  ```shell
  $ find /home/xipuhu -name “*.txt” -print
  ```

   find命令还有一个选项-iname（忽略字母大小写），该选项的作用和-name类似，只不过在匹配名字时会忽略大小写。
   如果想匹配多个条件中的一个，可以采用OR条件操作：

  ```shell
   $ find . \(-name “*.txt” -o -name “*.pdf”\) -print
  ```

- 选项-path的参数可以使用通配符来匹配文件路径。-name总是用给定的文件名进行匹配，-path则将文件路径作为一个整体进行匹配：

  ```shell
   $ find /homes/users -path “*/xipuhu/*” -print
   /home/users/list/xipuhu.txt
   /home/users/xipuhu/eg.css
  ```

- find也可以用“!”否定参数的含义，例如：

  ```shell
   $ find . ! -name “*.txt” -print
  ```


   上面的find命令能够匹配所有不以.txt结尾的文件名。

- find命令在使用时会遍历所有的子目录，我们可以采用深度选项-maxdepth和-mindepth来限制find命令遍历的目录深度，如果只允许find在当前目录中查找，深度可以设置为1：

  ```shell
   $ find . -maxdepth 1 -name “f*” -print
  ```

- Unix类系统将一切都视为文件。文件具有不同的类型，例如普通文件、目录、字符设备、块设备、符号链接、硬链接、套接字以及FIFO等，-type可以对文件搜索进行过滤：

  ```shell
   $ find . -type d -print  # 列出所有目录
   $ find . -type f -print  # 列出所有普通文件
   $ find . -type l -print  # 只列出符号链接
  ```

- Unix/Linux文件系统中的每一个文件都有三种时间戳：访问时间（-atime）、修改时间（-mtime）、变化时间（-ctime）。其中的变化时间是指，文件元数据（例如权限或所有权）最后一次改变的时间，而修改时间是指文件内容最后一次被修改的时间。
   -atime、-mtime、-ctime可以作为find的时间选项。它们可以用整数值指定，单位是天。这些整数值通常还带有-或+：-表示小于，+表示大于。

  ```shell
   $ find . -type f -atime -7 -print # 打印出在最近7内被访问过的所有文件
   $ find . -type f -atime 7 -print # 打印出恰好在7天前访问过的所有文件
   $ find . -type f -atime +7 -print # 打印出访问时间超过7天的所有文件
  ```

   类似地，我们也可以根据文件大小来进行搜索：

  ```shell
   $ find . -type f -size +2k    # 大于2KB的文件
   $ find . -type f -size -2M    # 小于2MB的文件
  ```

- -delete可以用来删除find查找到的匹配文件，比如，删除当前目录下所有的.swp文件：

  ```shell
   $ find . -type f -name “*.swp” -delete
  ```

- 也可以根据文件权限进行文件匹配：

  ```shell
   $ find . -type f -perm 644 -print  # 打印出权限为644的文件
  ```

#### 补充内容

- 利用find执行命令或动作，find命令可以借助选项-exec与其他命名进行结合，例如：

  ```shell
   # find . -type f -user root -exec chown xipuhu {} \;
  ```

   在这个命令中，{}是一个与-exec选项搭配使用的特殊字符串，对于每一个匹配的文件，{}会被替换成相应的文件名，比如，find命令找到两个文件test1.txt和test2.txt，其所有者均为xipuhu，那么find就会执行:
   chown xipuhu {}
   它会被解析为chown xipuhu test1.txt和chown xipuhu test2.txt
   再比如，用下面命令将10天前的.txt文件复制到OLD目录中：

  ```shell
   $ find . -type f -mtime +10 -name “*.txt” -exec cp {} OLD \;
  ```

- -exec结合多个命令，我们可以把多个命令写到一个shell脚本中，然后在-exec中使用这个脚本：

  ```shell
   -exec ./commands.sh {} \;
  ```

### xargs：将数据命令行参数化

　　我们可以用管道将一个命令的stdout（标准输出）重定向到另一命令的stdin（标准输入）。

例如：

```shell
cat foo.txt | grep “./test”
```

　　但是，有些命令只能以命令行参数的形式接受数据，而无法通过stdin接受数据流，这个时候，就该xargs命令出场了，它擅长将标准输入数据转换成命令行参数，即，xargs能够处理stdin并将其转换为特定命令的命令行参数。

　　xargs命令应该紧跟在管道操作符之后，以标准输入作为主要的源数据流，它使用stdin并通过提供命令行参数来执行其他命令。

#### 实战演练

- 将多行输入转换成单行输出，利用xargs，我们可以用空格替换掉换行符，这样就能够将多行文本转换成单行文本：

  ```shell
   $ cat example.txt # 样例文件
   1 2 3 4 5
   1 2 3
   1 2
   $ cat example.txt | xargs
   1 2 3 4 5 1 2 3 1 2
  ```

- 将单行输入转换成多行输出：

  ```shell
   $ cat example.txt | xargs -n 3 # 空格为默认的定界符，每行3个参数
   1 2 3
   4 5 1
   2 3 1
   2
  ```

- 可以用自己的定界符来分隔参数，用-d选项为输入指定一个定制的定界符：

  ```shell
   $ echo “splitXsplitXsplit” | xargs -d X -n 2
   split split 
   split
  ```

- 读取stdin，将格式化参数传递给命令，假如我们有一个shell脚本cecho.sh，这个脚本需要一个参数，则：

  ```shell
   $ cat args.txt | xargs -n 1 ./cecho.sh
  ```

   注意：每次执行需要X个参数的命令时，可以使用：

  ```shell
   INPUT | xargs -n X
  ```

- 上述例子中参数都源于args.txt文件，但实际上除了它们之外，我们还需要一些固定不变的命令参数，思考下面的这种命令格式：

  ```shell
   ./echo.sh -p arg1 -l
  ```

  　　 xargs有一个选项-I，可以提供上面这种形式的命令执行序列，我们可以用-I指定替换字符串，这个字符串在xargs扩展时会被替换掉，比如：

  ```shell
   $ cat args.txt | xargs -I {} ./cecho.sh -p {} -l
  ```


   -I {} 指定了替换字符串，对于每一个命令参数，字符串{}都会被从stdin读取到的数据替换掉。

#### 补充内容

- 结合stdin，巧妙运用while语句和子shell，xargs只能以有限的几种方式来提供参数，而且它也不能为多组命令提供参数，要执行包含来自标准输入的多个参数的命令，有一种非常灵活的方法。包含while循环的子shell可以用来读取参数：

  ```shell
   $ cat files.txt | ( while read arg; do cat %arg; done )  # 等同于cat files.txt | xargs -I {} cat {}
  ```

### 用tr进行转换

　　tr可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩。它可以将一组字符变成另一组字符，因为通常也被称为转换命令。tr只能通过stdin（标准输入），因而无法通过命令行参数来接受输入，它的调用格式如下：

```shell
tr [options] set1 set2
```

　　将来自stdin的输入字符从set1映射到set2，然后将输出写入stdout（标准输出）。set1和set2是字符类或字符集。如果两个字符集的长度不相等，那么set2会不断重复其最后一个字符，直到长度与set1相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。

#### 实战演练

- 将输入字符由大写转换成小写，可以使用下面的命令：

  ```shell
   $ echo “HELLO WHO IS THIS” | tr ‘A-Z’ ‘a-z’  # ‘A-Z’和‘a-z’都是集合
  ```


   注意：’ABD-}’、’aS.,’、’a-ce-x’以及‘a-c0-9’等均是合法的集合。定义集合也很简单，不需要书写一长串连续的字符序列，只需要用“起始字符-终止字符”这种格式就行了。如果“起始字符-终止字符”不是一个连续的字符序列，那么它就会被视为包含了3个元素的集合，也就是起始字符、-、终止字符。

- 用tr删除字符，tr有一个选项-d，可以通过指定需要被删除的字符集合，将出现在stdin中的特定字符清除掉：

  ```shell
   $ cat file.txt | tr -d ‘[set1]’  # 只使用set1，不使用set2
   例如：
   $ echo “Hello 123 world 456” | tr -d ‘0-9’
   Hello world
  ```

- 字符集补集，我们可以利用选项-c来使用set1的补集。下面的命令中，set2是可选的：

  ```shell
   $ tr -c [set1] [set2]
  ```

   set1的补集意味着这个集合中包含set1中没有的所有字符，最典型的用法是从输入文本中将不再补集中的所有字符全部删除：

  ```shell
   $ echo hello 1 char 2 next 4 | tr -d -c ‘0-9 \n’
  ```

- 用tr压缩字符，多数情况下，连续的重复字符应该压缩成单个字符，经常需要从事的一项任务就是压缩空白字符，tr的-s选项可以压缩输入中重复的字符：

  ```shell
   $ echo “GNU is  not     UNIX.” | tr -s ‘ ’
   GNU is not NUIX.
  ```

#### 补充内容

tr可以像使用集合一样使用各种不同的字符类，这些字符类如下所示：
 alnum：字母和数字
 alpha: 字母
 lower: 小写字母
 upper: 大写字母
 digit: 数字
 xdigit: 十六进制字符
 space: 空白字符
 print: 可打印字符
 graph: 图形字符
 cntrl: 控制（非打印）字符
 可以按照下面的方式选择并使用所需的字符类：
 tr [:class:] [:class:]
 比如：
 tr ‘[:lower]’ ‘[:upper:]’

### sort与uniq：排序、唯一与重复

　　同文本文件打交道时，少不了要用到排序。sort命令能够帮助我们对文本文件和stdin进行排序操作。它通常会配合其他命令来生成所需要的输出。uniq是一个经常与sort一同使用的命令。它的作用是从文本或stdin中提取到唯一（或重复）的行。sort命令既可以从特定的文件，也可以从stdin中获取输入，并将输入写入stdout。

#### 实战演练

- 我们可以按照下面的方式轻松地对一组文件进行排序：

  ```shell
   $ sort file1.txt file2.txt > sort.txt
   或是
   $ sort file1.txt file2.txt -o sort.txt
  ```

- 按照数字顺序进行排序：

  ```shell
   $ sort -n file.txt
  ```

- 按照逆序进行排序：

  ```shell
   $ sort -r file.txt
  ```

- 按照月份进行排序（依照一月、二月…）：

  ```shell
   $ sort -M months.txt
  ```

- 合并两个已经排序过的文件：

  ```shell
   $ sort -m sorted1 sorted2
  ```

- 找出已排序文件中不重复的行：

  ```shell
   $ sort file1.txt file2.txt | uniq
  ```

- 检查文件是否已经排序过：

  ```shell
   #!/bin/bash
   sort -C filename;
   if [ $? -eq 0 ]; then
     echo Sorted
   else
     echo Unsorted
   fi
   如果文件已经排序，sort会返回为0的退出码（$?），否则返回非0。
  ```

- uniq命令通过消除重复内容，从给定输入中（stdin或命令行参数文件）找出唯一的行。它也可以用来找出输入中出现的重复行：

  ```shell
   $ cat sorted.txt
   bash
   foss
   hack
   hack
  
   $ uniq sorted.txt
   bash
   foss
   hack
   或是
   $ sort unsorted.txt | uniq
  ```

- 只显示唯一的行（在输入文件中没有重复出现的行）：

  ```shell
   $ uniq -u sorted.txt
   fash
   foss
  ```

- 要统计各行在文件中出现的次数，使用下面的命令：

  ```shell
   $ sort unsorted.txt | uniq -c
   1 bash
   1 foss
   2 hack
  ```

- 找出文件中重复的行：

  ```shell
   $ sort unsorted.txt | uniq -d
   hack
  ```

#### 补充内容

- uniq只能作用于排过序的数据输入，因此，uniq要么使用管道，要么将排过序的文件作为输入，与sort命令结合使用。

### %和#操作符：根据扩展名切分文件名

　　有一些脚本是依据文件名进行各种处理的，我们可能会需要在保留扩展名的同时修改文件名、转换文件格式（保留文件名的同时修改扩展名）或提取部分文件名。借助%操作符可以轻松将名称部分从“名称.扩展名”这种格式中提取出来。而将文件名中的扩展名部分提取出来，则需要借助#操作符来实现。

#### 实战演练

- 从sample.jpg中提取名称：

  ```shell
   file_name=”sample.jpg”
   name=${file_jpg%.*}
   echo File name is : $name
  ```

- 提取文件名中的.jpg并存到变量file_jpg中：

  ```shell
   extension=${file_jpg#*.}
   echo Extension is : extension
  ```

- %属于非贪婪操作，它从右到左找出匹配通配符的最短结果。还有另一个操作符%%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串：

  ```shell
   VAR=hack.fun.hook.txt
   $ echo ${VAR%.*}  # 得到的输出：hack.fun.hook
   $ echo ${VAR%%.*} # 得到的输出：hack
   操作符%%用.*从右到左执行贪婪匹配（.fun.book.txt）。
  ```

- 和%%类似，\#也有一个相对应的贪婪操作符\#\#

  ```shell
   VAR=hack.fun.book.txt
   $ echo ${VAR#*.}  # 得到输出：fun.book.txt
   $ echo ${VAR##*.}  # 得到输出：txt
   操作符#用*.从左向右执行非贪婪匹配（hack），操作符##用*.从左向右执行贪婪匹配（txt）
  ```

#### 补充内容

- ${VAR%.*}的含义有如下解释：
   1.从$VAR中删除位于%右侧的通配符（在前面是.*）所匹配的字符串。通配符从右向左进行匹配。
   2.给VAR赋值。VAR=sample.jpg、那么，通配符从右向左就会匹配到.jpg，因此，从$VAR中删除匹配结果，就会输出sample。

### rename：批量重命名和移动

　　重命名多个文件是我们经常会碰到的一项工作，还有另一件经常要做的工作是，将文件名中包含某个特定部分（例如相同的前缀）或者具有特定类型的所有文件移动到指定的文件夹中，通过使用Bash命令可以在短短几秒中之内完成这些内容！rename命令利用Perl正则表达式修改文件名，综合运用find、rename和mv，我们能做到的事其实有很多。

#### 实战演练

- 用特定的格式重命名当前目录下的图像文件：

  ```shell
   #!/bin/bash
   # 文件名：rename.sh
   # 用途：重命名.jpg和.png文件
   count=1;
   for img in ‘find . -iname ‘*.png’ -o -iname ‘*.jpg’ -type f -mxdepth 1’
   do
     new=image-$count.${img##*.}
     echo “Renaming $img to $new”
     mv “$img” “$new”
     let count++
   done
   输出如下：
   $ ./rename.sh
   Renaming hack.jpg to image-1.jpg
   Renaming new.png to image-2.png
  ```

- 将*.JPG更名为*.jpg：

  ```shell
   $ rename *.JPG *.jpg
  ```

- 将文件名中的空格替换成字符“\_”：

  ```shell
   $ rename ‘s/ /_/g’ *  # ‘s/ /_/g’用于替换文件名，而*是用于匹配所有目标文件的通配符
  ```

- 转换文件名的大小写：

  ```shell
   $ rename ‘y/A-Z/a-z/’ *
   $ rename ‘y/a-z/A-Z/’ *
  ```

- 将所有的.mp3文件移入给定的目录：

  ```shell
   $ find path -type f -name “*.mp3” -exec mv {} target_dir \;
  ```

- 将所有文件名中的空格符替换为字符“_”：

  ```shell
   $ find path -type f -exec rename ‘s/ /_/g’ {} \;
  ```

### script和scriptreplay：录制并回放终端会话

　　利用script和scriptreplay命令，我们可以录制命令的次序以及时序，将相关数据记录在文本文件中。利用这些文件，其他人可以在终端上回放并查看命令的输出。

#### 实战演练

- 开始录制终端会话（其中-t选项用于将时序数据导入stderr）：

  ```shell
   $ script -t 2> timing.log -a output.session
   type commands;
   …
   exit
  ```


   注意：对于不支持单独将stderr重定向到文件的shell，这个攻略是没法使用的。 

- 利用这两个文件，timing.log（存储时序信息）和output.session（存储命令输出信息），我们可以按照下面的方法回放命令执行过程：

  ```shell
   $ scriptreplay timing.log output.session # 按顺序播放命令序列输出
  ```