---
title: 第三章：以文件之名
categories: [读书笔记,Linux shell脚本攻略]
tags: [shell]
toc: true
---

### 文件权限、所有权和粘滞位

　　Linux系统中的每一个文件都与多种类型的权限有关联。在这些权限中，我们通常要和三类权限打交道（用户、用户组以及其他用户）：

<!--more-->

- 用户（user）是文件的所有者。
- 用户组（group）是多个用户的集合（由系统管理员指定），系统允许这些用户对文件进行某种形式的访问。
- 其他用户（others）是除文件用户或用户组之外的任何人。

　　用命令ls -l可以列出文件的权限：

```shell
-rw-r--r-- 1 xipuhu xipuhu 2497 2019-11-03 11:22 bot.py

drwxr-xr-x 2 xipuhu xipuhu 4096 2019-11-03 14:31 a.py
```

　　第一列输出明确了后面的输出，其中第一个字母的对应关系如下所示：

- \- ————普通文件
- d ————目录
- c ————字符设备
- b ————块设备
- l ————符号链接
- s ————套接字
- p ————管道

　　剩下的部分可以划分成三组，每组3个字符。第一组的3个字符（rwx------）对应用户权限（所有者），第二组（---rwx---）对应用户组权限，第三组（------rwx）对应其他用户权限：

- u ————指定用户权限
- g ————指定用户组权限
- o ————指定其他用户权限

　　目录同样也有读、写、执行权限。不过对于目录来说，读、写、执行权限的含义有点不一样：

- 目录的读权限（r）允许读取目录文件和子目录的列表；
- 目录的写权限（w）允许在目录中创建或删除文件和目录；
- 目录的执行权限（x）指明是否可以访问目录中的文件和子目录。

　　目录还有一个特出的权限，叫做粘滞位（sticky bit）。如果目录设置了粘滞位，只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，也无能为力。粘滞位出现在其他用户权限中的执行权限（x）的位置。它使用t或T来表示。如果没有设置执行权限，但设置了粘滞位，就使用t（------rwt）；如果同时设置了执行权限和粘滞位，就使用T（------rwT）。

#### 实战演练

- 可使用chmod命令设置文件权限：

  ```shell
   $ chmod u=rex g=rw o=r filename # rwxrw-r—
  ```

- 可以对用户、用户组和其他用户用+进行添加权限，用-删除权限，比如对上述的权限进修改：

  ```shell
   $ chmod o+x filename  # 修改后的权限：rwxrw-r-x
  ```

- 给所有权限类别（用户、用户组和其他用户）增加可执行权限：

  ```shell
  $ chmod a+x filename  # a(all)表示所有权限类别
  ```

- 也可以用八进制数来设置权限，权限由3位八进制数来表示，每一位按顺序分别对应用户、用户组和其他用户：
   r-- =4 
   -w- =2
   --x =1
   我们可以将权限序列的八进制值相加来获得所需的权限组合，例如：
   rw- = 4 + 2 = 6
   r-x = 4 + 1 = 5
   r-- = 4
   因此，rw- rw- r-- 等于654，那么使用八进制值设置权限的命令为：

  ```shell
  $ chmod 654 filename   
  ```

- 要更改文件的所有权（更改用户名和用户组名），可以使用chown命令：

  ```shell
   $ chown user:group filename
   例如：
   $ chown xipuhu:xipuhu test.sh # 这里xipuhu既是用户名，也是用户组名。   
  ```

- 设置粘滞位：

  ```shell
   $ chmod a+t directory_name
  ```

- 有时候需要以递归方式修改当前目录下的所有文件和子目录的权限，方法如下：

  ```shell
   $ chmod 777 . -R
  ```

- 以递归的方式设置所有权：

  ```shell
   $ chown user:group . -R
  ```

### 创建不可修改的文件

　　在常见的Linux扩展文件系统中（如ext2、ext3、ext4等），可以借助某种文件属性将文件设置为不可修改，一旦设置，任何用户（包括超级用户）都不能删除该文件，除非其不可修改的属性被移除。通过查看/etc/mtab文件，我们很容易获知所有挂载分区的文件系统类型。这个文件的第一列指定了分区设备路径（如/dev/sda5），第三列指定了文件系统类型（如ext3）。

#### 实战演练

- chattr能够将文件设置为不可修改：

  ```shell
   # chattr +i file
  ```

- 如果需要使文件恢复可写状态，移除不可修改属性即可：

  ```shell
   # chattr -i file
  ```

### 查找符号链接及其指向目标

　　符号链接在类Unix系统中很常见，使用它的理由有很多，要么是为了便于存取，要么是为了维护相同代码库或程序的不同版本。符号链接只不过是指向其他文件的指针，它的功能上类似于Mac OS中的别名或Windows中的快捷方式。删除符号链接不会影响到原始文件。

#### 实战演练

- 创建符号链接：

  ```shell
   $ ln -s target symbolic_link_name
   例如：
   $ ln -l -s /var/www/ ~/web # 创建了一个名为web的符号链接，该链接指向/var/www。
  ```

- 使用下面的命令来验证是否创建链接：

  ```shell
   $ ls -l wab
   lrwxrwxrwx 1 xipuhu xipuhu 8 2019-11-04 21:34 web -> /var/www
  ```

### 列举文件类型统计信息

　　find命令可以通过查看文件内容来找出特定类型的文件。在Unix/Linux系统中，文件类型并不是由文件扩展名决定的（在Windows平台中是这么做的）。

#### 实战演练

- 用下面的，命令打印文件类型信息：

  ```shell
   $ file filename
   $ file /etc/passwd
   /etc/passwd: ASCII text
  ```

- 打印不包括文件名在内的文件类型信息：

  ```shell
   $ file -b filename
   ASCII text
  ```

### 使用head与tail打印文件的前10行和后10行

　　当查看上千行的大文件时，我们可不会用cat命令把整个文件内容给打印出来。相反，我们只会查看文件的一小部分内容（例如前10行和后10行），head和tail命令可以帮助我们实现这些需求。

#### 实战演练

- 打印前10行：

  ```shell
   $ head file
  ```

- 从stdin读取数据：

  ```shell
   $ cat text | head
  ```

- 指定打印前几行：

  ```shell
   $ head -n 4 file # 该命令会打印文件的前4行
  ```

- 打印除了最后M行之外所有的行：

  ```shell
   $ head -n -M file # 注意：-M表示一个负数，并非选项
  ```

- 打印文件的最后10行：

  ```shell
   $ tail file
  ```

- 打印最后5行：

  ```shell
   $ tail -n 5 file
  ```

- 打印除了前M行之外所有的行：

  ```shell
   $ tail -n +(M+1)
   例如，打印除前5行之外的所有行，M+1=6，因此使用下列命令：
   $ sea 100 | tail -n +6 # 这条命令将打印胡第6行至第100行
  ```

#### 补充内容

- tail命令的一个重要用法是从一个内容不断增加的文件中读取数据。新增加的内容总是被添加到文件的尾部，因此当新内容被写入文件的时候，可以用tail命令将其显示出来。为了能够不间断地监视文件的增长，tail有一个特殊的选项-f或--follow,它们会是tail密切关注文件中新添加的内容，并随着数据的增加持续保持更新：
   $ tail -f growing_file  \# 你可能希望将其用于日志文件

### 在命令行中使用pushd和popd进行快速定位

　　pushd和popd可以用于在多个目录之间进行切换而无需复制并粘贴目录路径。pushd和popd以栈的方式来运作。使用pushd和popd时，可以无视cd命令。

#### 实战演练

- 压入并切换路径：

  ```shell
   ~$ pushd /var/www # 现在，栈中包含了/var/www ~，当前目录切换到/var/www。
  ```

- 再压入下一个目录：

  ```shell
   /var/www $ pushd /usr/src
  ```

- 用下面的命令查看栈内容：

  ```shell
   /usr/src $ dirs
   /usr/src /var/www ~ 
   0    1    2
  ```

- 当你想切换到列表中任意路径时，将每条路径从0到n进行编号，然后使用你希望切换到的路径编号，例如：

  ```shell
   $ pushd +2 # 这条命令会将栈进行翻转并切换到目录~。
  ```

- 要删除最后添加的路径并把当前目录更改为上一级目录，可以使用以下命令：

  ```shell
   ~$ popd # popd会将栈 ~ /usr/src /var/www更改为/usr/src /var/www并把目录切换到/var/www
  ```

- 用popd +num可以从列表中移出特定的路径。

- 当涉及3个以上的目录时，可以使用pushd和popd。但是如果只涉及两个位置的时候，还有另一个更简便的方法：cd -。

### 统计文件的行数、单词书和字符数

　　wc是一个用于统计的工具，它是Word Count（单词统计）的缩写。使用wc可以统计文件的行数、单词数和字符数。

#### 实战演练

- 统计行数：
   $ wc -l file
- 如果需要将stdin作为输入，使用下列命令：
   $ cat file | wc -l
- 统计单词数：
   $ wc -w file
- 当不使用任何选项执行wc时：
   $ wc file
   1435 15673 112200
   它会分别打印出文件的行数、单词数和字符数。

### 用tar归档

　　提取快照和备份数据都是我们的日常工作，就服务器或大型数据存储系统而言，定期备份更是不可小视。加密是另外一种保护数据的常用方法，为了减少加密数据的大小，文件在加密之前通常都要先进行归档和压缩。
　　tar命令可以对文件进行归档。它最初是设计用来将数据存储在磁带上。tar可以将多个文件和文件夹保存为单个文件，同时还能保留所有的文件属性，如所有者、权限等。所有Unix类操作系统中都默认包含tar命令。它语法简单，文件格式具备可移植性。tar支持的参数包括：A、c、d、r、u、x、f和v。

#### 实战演练

- 用tar对文件进行归档：

  ```shell
   $ tar -cf output.tar [file1 file2…] 
   -c代表“创建文件”（create file），-f代表“指定文件名”（specify filename）。
  ```

- 使用选项-t列出归档文件中所包含的文件：

  ```shell
   $ tar -tf archive.tar
   file1
   file2
  ```

- 向已有的归档文件中添加一个文件：

  ```shell
   $ tar -rvf original.tar new_file
  ```

- 将归档文件的内容提取到当前目录中：

  ```shell
   $ tar -xf archive.tar
   -x表示提取（exact）
  ```

- 我们也可以用选项-C来指定需要将文件提取到哪个目录：

  ```shell
   $ tar -xf archive.tar -C /path/to/extraction_directory
  ```

- 还可以通过将文件名指定为命令行参数提取特定的文件：

  ```shell
   $ tar -xvf file.tar file1 file4
  ```

- 我们可以用--delete选项从给定的归档文件中删除文件：

  ```shell
   $ tar -f archive.tar --delete file1 file2..
  ```

#### 补充内容

- 在使用tar时，文件名必须紧跟在-f之后，而且-f应该是选项中的最后一个。

- tar命令只能用来对文件进行归档，它并不具有压缩功能。

- 归档文件通常可以被压缩成下列各式之一：
   file.tar.gz
   file.tar.bz2
   file.tar.lzma
   不同的tar选项可以用来指定不同的压缩格式：
   -j指定zip2格式；
   -z指定gzip格式；
   —lzma指定lzma格式

- 为了让tar支持根据扩展名自动进行压缩，使用-a或--auto-compress选项：

  ```shell
   $ tar -acvf archive.tar.gz filea fileb filec
   $ tar -tf archive.tar.gz
   filea
   fileb
   filec
  ```

- 通过指定模式可以从归档文件中排除部分文件。用--exclude [PATTERN]排除匹配通配符样式的文件：

  ```shell
   $ tar -cf arch.tar * —exclude “*.txt” # 排除所有的.txt文件
  ```

### 使用gzip压缩数据

　　gzip只能压缩单个文件或数据流，而无法对目录和多个文件进行归档，因此我们需要先创建tar归档文件，然后再用gzip进行压缩。

#### 实战演练

- 要使用gzip压缩文件，可以使用下面的命令：

  ```shell
   $ gzip filename
   $ ls
   filename.gz
  ```

- 将gzip文件解压缩的方法如下：

  ```shell
   $ gunzip filename.gz
   $ ls
   file
  ```

- 列出压缩文件的属性信息：

  ```shell
   $ gzip -l test.tar.gz
   compressed uncompressed ratio  uncompressed_name
   35     6       -33.3% test.txt
  ```

### 用zip归档和压缩

　　ZIP作为一种流行的压缩格式，在很多平台中都可以看到它的身影。在Linux下，它的应用不如gzip或bzip2那么广泛，但是Intern上的文件通常都采用这种格式。

#### 实战演练

- 对归档文件采用ZIP格式进行压缩：
   $ zip archive_name.zip [SOURCE FILES/DIRS]
- 对目录和文件进行递归操作：
   $ zip -r archive.zip folder1 folder2
- 要从ZIP文件中提取内容，可以使用：
   $ unzip file.zip
- 如果需要更新压缩文件中的内容，可以使用选项-u：
   $ zip file.zip -u newfile
- 从压缩文件中删除内容，则使用-d：
   $ zip -d arc.zip file.txt
- 列出压缩文件中的内容：
   $ unzip -l archive.zip

#### 补充内容

- 在完成提取操作之后，unzip并不会删除file.zip（这一点与unlzma和gunzip不同）。

### 用rsync备份系统快照

　　rsync可以对位于不同位置的文件和目录进行同步，它利用差异计算以及压缩技术来最小化数据传输量。相对于cp命令，rsync的优势在于使用了高效的差异算法。另外，它支持网络数据传输。在进行复制的同时，rsync会比较源端和目的端的文件，只有当文件有更新时才进行复制。

#### 实战演练

- 将源目录复制到目的端：

  ```shell
   $ rsync -av source_path destination_path
   例如：
   $ rsync -av /home/xipuhu/data xipuhu@192.168.0.6:/home/backups/data
   其中：
   -a表示要进行归档；
   -v表示在stdout上打印出细节信息或进度
  ```

- 将数据备份到远程服务器或主机：

  ```shell
   $ rsync -av source_dir username@host:PATH
  ```


   如果需要在目的端建立一份镜像，只需要定期运行同样的rsync命令即可，它只会对更改过的文件进行复制。

- 用下面的方法将远程主机上的数据恢复到本地主机：

  ```shell
   $ rsync -av username@host:PATH destination
  ```

- 通过网络进行传输时，压缩数据能够明显改善传输效率：

  ```shell
   $ rsync -avz source destination
  ```

- 将一个目录中的内容同步到另一个目录：

  ```shell
   $ rsync -av /home/test/ /home/backups
  ```

- 对远端内容进行归档时，有些文件并不需要进行更新，我们可以告知rsync将某些文件从本次操作中排除：

  ```shell
   $ rsync -avz /home/code/some_code /mnt/disk/backup/code --exclude “*.txt”
   该命令不对.txt文件进行备份。
  ```

- 默认情况下，rsync并不会在目的端删除那些在源端已不存在的文件。如果要删除这些已不存在文件，使用rsync的--delete选项：

  ```shell
   $ rsync -avz SOURCE DESTINATION --delete
  ```

- 我们可以创建一个cron任务来定期进行备份：

  ```shell
   $ crontab -ev
  ```

   加上这么一行：
   0 */10 * * * rsync -avz /home/code user@IP_ADDRESS:/home/backups
   上面的crontab条目将rsync调度为每10小时运行一次，*/10处于crontab语法中的钟点位，/10表示每10小时执行一次备份。如果*/10出现在分钟位，那就是每10分钟执行一次备份。

#### 补充内容

- 就路径格式而言，如果我们在源路径末尾使用/（即路径写成/home/test/），那么rsync会将source_path尾端目录中的所有内容复制到目的端。如果没有使用/,rsync会将source_path尾端目录本身复制到目的端。

### 用Git进行基于版本控制的备份

　　在备份数据时，我们只需要复制那些在备份之后发生变化的那些文件，这叫做增量备份。可以用rsync这类工具来手动创建增量备份，不过回复这种备份可不是件容易的事。维护和恢复变更的最好方法是使用版本控制系统。

#### 实战演练

- 进入需要备份的目录：

  ```shell
   $ cd /home/data/source # 将其作为需要被跟踪的目录源
  ```

- 设置并初始化远端备份目录，在远程主机中创建备份目录：

  ```shell
   $ mkdir -p /home/backups/backup.git
   $ cd /home/backups/backup.git
   $ git init --bare
  ```

在源主机中执行下列步骤：

- 在源主机中将用户详细信息添加到Git：

  ```shell
   $ git config --global user.name “xipuhu”
   $ git config --global user.email xipuhu@xipuhu.com
  ```

- 初始化目录中需要进行备份的目录。在源目录中执行下列命令：

  ```shell
   $ git init
   Initialized empty Git repository in /home/backups/backup.git/
   $ git commit --allow-empty -am “Init”
   [master (root-commit) b595488] Init
  ```

- 在源目录中执行下列命令来添加远程Git目录并同步备份：

  ```shell
   $ git remote add origin user@remotehost:/home/backups/backup.git
   $ git push origin master
  ```

- 为Git跟踪添加或删除文件：

  ```shell
   $ git add * # 将当前目录下的所有文件和文件夹添加到备份列表中
   $ git add *.txt # 添加.txt文件
   $ git rm file # 删除不需要跟踪的文件和文件夹
  ```

- 用下列命令来标注一个附带消息的备份的检查点：

  ```shell
   $ git commit -m “Commit Message”
  ```

- 定期更新远端的备份，因此得设置一个cron任务（例如，每5小时进行一次备份）：

  ```shell
   0 */5 * * * /home/data/backup.sh # 创建一个crontab条目
   创建脚本/home/data/backup.sh:
   #!/bin/bash
   cd /home/data/source
   git add .
   git commit -am “Backup taken at @ $(date)”
   git push
  ```

- 查看所有版本的备份：

  ```shell
   $ git log
  ```

- 要恢复到之前的某个状态或版本，需要查看一个由32位十六进制串组成的提交ID：

  ```shell
   如果提交ID为3131f9661ec1739..，那就是：
   $ git checkout 3131f9661ec1739..  # 总共32位数“..”用于省略表示
  ```

  