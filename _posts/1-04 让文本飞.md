---
title: 第四章：让文本飞
categories: [读书笔记,Linux shell脚本攻略]
tags: [shell]
toc: true
---

### 使用正则表达式

　　文本处理是shell脚本擅长的重要领域之一，它可以与sed、awk、grep这类优美的工具组合在一起来解决文本处理相关的问题。正则表达式是基于模式匹配的文本处理技术的关键所在，借助适合的正则表达式，可以生成我们所需的各类输出结果，例如过滤、剥离（strip）、替换、搜索等。

<!--more-->

　　通配符能够匹配的文本范围相当有限。正则表达式是一种用于文本匹配的形式小巧、具有高度针对性的编程语言。正则表达式是由字面文本和具有特殊意义的符号组成的。我们可以根据具体需求，使用它们构造出合适的正则表达式来匹配文本。以下是正则表达式的基本组成部分，如表4-1所示：

<img src="https://hexo-blog-1258021165.cos.ap-guangzhou.myqcloud.com/shell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5/01.png" width=60% height=60%>



### 用grep在文件中搜索文本

　　在文件中进行搜索是文本处理中的一项重要工作。我们也许需要在某些多达上千行的文件中进行查找所需的数据，grep命令作为Unix中用于文本搜索的神奇工具，能够接受正则表达式生成各种格式的输出。

#### 实战演练

- 搜索包含特定模式的文本行：

  ```shell
   $ grep pattern filename
   或者：
   $ grep “patern” filename
  ```

- 也可以像下面这样从stdin中读取：

  ```shell
   $ echo -e “This is a word\nnext line” | grep word
   This is a word
  ```

- 单个grep命令也可以对多个文件进行搜索：

  ```shell
   $ grep “pattern” file1 file2 file3..
  ```

- 用--color选项可以在输出行中着重标记出匹配到的单词：

  ```shell
   $ grep world filename --color=auto
  ```

- grep命令只解释”pattern”中的某些特殊字符。如果要使用正则表达式，需要添加-E选项——这意味着使用扩展正则表达式。或者也可以使用默许允许正则表达式的grep命令——egrep。例如：

  ```shell
   $ grep -E “[a-z]+” filename
   或者：
   $ egrep “[a-z]+” filename
  ```

- 统计文件或文本中包含匹配字符串的行数：

  ```
   $ grep -c “text” filename
   10
  ```

   需要注意的是-c只是统计匹配行的数量，并不是匹配的次数：

  ```shell
   $ echo -e “1 2 3 4\nhello\n5 6” | egrep -c “[0-9]”
   2
  ```

- 打印出包含匹配字符串的行号：

  ```shell
   $ grep linux -n sample.txt
   2:linux is fun
  ```

   如果涉及到多个文件，它也会随着输出结果打印出文件名：

  ```shell
   $ grep linux -n sample1.txt sample2.txt
   sample1.txt:2:linux is fun
   sample2.txt:2:planetlinux
  ```

- 如果需要在多级目录中对文本进行递归搜索，可以使用：

  ```shell
   $ grep “text” . -R -n  # grep的选项-R和-r功能一样
   例如：
   $ cd src_dir
   $ grep “test_function()” . -R -n
   ./miscutils/test.c:16:test_function(); 
   这是开发人员使用最多的命令之一，它用于查找某些文本位于哪些源码文件中。
  ```

- 选项-i可以是匹配样式不考虑字符的大小写：

  ```shell
   $ echo hello world | grep -i “HELLO”
   hello
  ```

- 在进行匹配的时候通常只指定一个样式，然而我们可以用选项-e来指定多个匹配样式：

  ```shell
   $ grep -e “pattern1” -e “pattern”
   例如：
   $ echo this is a line of text | grep -e “this” -e “line” -o
   this
   line
   注意：选项-o表示只输出文件中匹配到的文本部分。
  ```

- 在grep搜索中指定或排除文件：

  ```shell
   目录中递归搜索所有的.c和.cpp文件：
   $ grep “main()” . -r --include *.{c,cpp}
   在搜索中排除所有的README文件：
   $ grep “main()” . -r --exclude “README”
  ```

#### 补充内容

- 使用0值字节作为后缀的grep与xargs：
   xargs命令通常用于将文件名列表作为命令行参数提供给其他命令。当文件名用作命令行参数时，建议用0值字节作为文件名终止符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符，那么单个文件名就会被误认为是两个文件名（例如，New file.txt被解析成New和file.txt两个文件名）。这个问题可以利用0值字节后缀来避免。为了指明输入的文件名是以0值字节（\0）作为终止符，需要在xargs中使用-0。在下列命令中，greap使用-Z选项输出以0值字节作为终结符的文件名（\0）。xargs -0读取输入并用0值字节终结符分隔文件名：

  ```shell
   $ grep “test” file* -lZ | xargs -0 rm
  ```

- 打印出匹配文本之前或之后的行：

  ```shell
   要打印匹配某个结果之后的2行，使用-A选项：
   $ seq 10 | grep 5 -A 2
   5
   6
   7
   要打印匹配某个结果之前的2行，使用-B选项：
   $ seq 10 | grep 5 -B 2
   3
   4
   5
   要打印匹配某个结果之前及之后的2行，使用-C选项
   $ seq 10 | grep 5 -C 2
   3
   4
   5
   6
   7
  ```

### 使用sed进行文本替换

　　sed是流编辑器（stream editor）的缩写，它是文本处理中不可或缺的工具，能够配合正则表达式使用。

#### 实战演练

- sed可以替换给定文本中的字符串：

  ```shell
   $ sed ‘s/pattern/replace_string/’ file
   或者
   $ cat file | sed ‘s/pattern/replace_string/’ # 该命令从stdin中读取输入
  ```

- 默认情况下，sed只会打印替换后的文本。如果需要在替换的同时保存更改，可以使用-i选项，可以将替换结果应用于原文件。很多用户在进行替换后，会借助重定向来保存文件：

  ```shell
   $ sed ‘s/text/replace/’ file >newfile
   $ mv newfile file
   其实只需要一行命令就可以搞定：
   $ sed -i ‘s/text/replace/’ file
  ```

- 之前看到的sed命令会将每一行第一处符合模式的内容替换掉。但是如果要替换所有内容，我们需要在命令尾部加上参数g：

  ```shell
   $ sed ‘s/pattern/replace_string/g’ file
  ```

- 用sed很容易就可以移出空白行，空白行可以用正则表达式^$进行匹配：

  ```shell
   $ sed ‘/^$/d’ file
   /pattern/d会移出匹配样式的行。在空白行中，行尾标记紧随着行首标记。
  ```

- 如果我们想修改文件的内容，一种有益的做法是先使用不带-i选项的sed命令，以确保正则表达式没有问题，一旦结果符合要求，再加入-i选项将更改写入文件。另外，你也可以使用下面形式的sed：

  ```shell
   $ sed -i.bak ‘s/abc/def/’ file
   这时sed不仅执行文件的内容替换，还会创建一个名为file.bak的文件，其中包含这原始文件内容的副本。
  ```

- 在sed中，我们可以用&标记匹配样式的字符串，这样就能够在替换字符串时使用已匹配的内容：

  ```shell
   $ echo this is an example | sed ‘s/\w\+/[&]/g’
   [this] [is] [an] [example]
  ```

- sed表达式通常用单引号来引用。不过也可以使用双引号。双引号会通过对表达式求值来对其进行扩展。当我们想在sed表达式中使用一些变量时，双引号就能派上用场了：

  ```shell
   $ text=hello
   $ echo hello world | sed “s/$text/HELLO/”
   HELLO world
  ```

### 使用awk进行高级文本处理

　　awk是一款设计用于数据流的工具。它颇有玩头的原因就在于可以对列和行进行操作。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处。灵活性是awk最大的优势。
awk脚本的结构基本如下所示：

```shell
awk ‘BEGIN{ print “start” } pattern { commands } END{ print “end”}’ file
```

　　awk命令也可以从stdin中读取。awk脚本通常由3部分组成，BEGIN，END和带模式匹配选项的常见语句块。这3个部分都是可选项，在脚本中可省略任意部分。

awk命令的工作方式：

1. 执行BEGIN { commands }语句块中的语句；
2. 从文件或stdin中读取一行，然后执行pattern { commands }。重复这个过程，知道文件全部被读取完毕；
3. 当读取至输入流末尾时，执行END { commands }语句块。

　　BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，诸如变量初始化、打印出表格的表头等语句通常都可以写入BEGIN语句块中。
　　END语句块和BEGIN语句块类似。END语句块在awk从输入流中读取完所有的行之后即被执行。像打印所有行的分析结果这类汇总信息，都是在END语句块中实现的常见任务（例如，在比较过所有的行之后，打印出最大数）。
　　最重要的部分就是pattern语句块中的通用命令。这个语句块同样是可选的。如果不提供该语句块，则默认执行{ print }，即打印所读取到的每一行。awk对于每一行，都会执行这个语句块。这就像一个用来读取行的while循环，在循环体中提供了相应的语句。

**实战演练**

- 以下awk脚本被包含在单引号或双引号之间：

  ```shell
   awk ‘BEGIN { statements } { statements } END { end statements}’
   也可以使用：
   awk “BEGIN { statements } { statements } END { end statements}”
   例如：
   $ awk ‘BEGIN { i=0 } { i++ } END { print i }’ filename
  ```

- 打印每一行的第2和第3个字段：

  ```shell
   $ awk ‘{ print &3, $2 }’ file
  ```

- 要统计文件中的行数：

  ```shell
   $ awk ‘END{ print NR}’ file
  ```

- 借助选项-v，我们可以将外部值（并非来自stdin）传递给awk：

  ```shell
   $ VAE=1000
   $ echo | ask -v VARIABLE=$VAR ‘{ print VARIABLE }’
   1000
  ```

#### 补充内容

- 特殊变量：
   NR：表示记录数量，在执行过程中对应于当前行号；
   NF：表示字段数量，在执行过程中对应于当前行的字段数；
   $0：这个变量包含执行过程中当前行的文本内容；
   $1：这个变量包含第一个字段的文本内容；
   $2：这个变量包含第二个字段的文本内容。
- awk内建的字符串控制函数：
   length(string)：返回字符串的长度；
   index(string, search)：返回search在字符串中出现的位置；
   split(sting, array delimiter)：用定界符生成一个字符串列表，并存入数组array；
   substr(string, start, end)：在字符串中用字符起止偏移量生成子串并返回；
   sub(regex, replace, string)：将正在表达式匹配到的第一处内容替换成replace；