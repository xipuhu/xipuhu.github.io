---
title: 第一章：小试牛刀
categories: [读书笔记,Linux shell脚本攻略]
tags: [shell]
toc: true
---

### 简介

　　本章的主要目的是让读者了解shell环境并熟悉shell的基本特性。命令都是在shell终端中输入并执行，打开终端后，就会出现一个提示符。其形式通常如下：

<!--more-->

```shell
username@hostname$
或者：
root@hostname#
注意：$ 表示普通用户，#表示管理员用户root。root是Linux系统中权限最高的用户。
```

#### shebang

　　通常shell脚本通常是一个以shebang起始的文本文件，如下所示：

　　\#!/bin/bash

其中#!位于解释器路径之前，/bin/bash是Bash的解释器命令路径。将脚本作为命令行参数时的运行方式如下：

```shell
$ bash script.sh   #假设脚本位于当前目录下
或者
$ chmod a+x script.sh #要求文件具有可读可执行权限
$ ./script.sh

$cmd1;cmd2  #在Bash中每个命令或是命令序列是通过使用分号或换行符来分隔的
它等同于：
$cmd1
$cmd2
```

### 文件配置

　　当启动shell时，它一开始会执行一组命令来定义诸如提示文本、颜色等各类设置。这组命令来自位于用户主目录的脚本文件~/.bashrc。Bash还维护了一个历史记录文件~/.bash_history，用于保存用户运行过的命令。

### 终端打印

#### 两种打印命令echo和printf

　　echo是用于终端打印的基本命令，在默认情况下，echo在每次调用后会添加一个换行符。所打印的内容可以使用带双引号、不带双引号和带单引号这三个版本，每个版本之间的副作用如下所述：

- 使用不带双引号的echo时，没法在所要显示的文本中使用分号(;)，因为分号在Bash shell中被用作命令界定符。
- 以echo hello;hello为例，echo hello被视为一个命令，第二个hello则被视为另一个命令。
- 变量替换在单引号中无效。

　　另一个可用于终端打印的命令是printf，printf使用的参数和C语言中的printf函数一样，printf使用引用文本或有空格分隔的参数，我们可以在printf中使用格式化字符串，还可以指定字符串的宽度、左右对齐方式等。在默认情况下，printf并不像echo命令一样会自动添加换行符，我们必须在需要的时候手动添加。%s、%c、%d和%f都是格式替换符，其所对应的的参数可以置于带引号的格式字符串之后。比如，%-5s指明了一个格式为左对齐且宽度为5的字符串替换（-表示左对齐），如果不用-指定对齐方式，字符串就采用右对齐的方式。宽度指定了保留给某个变量的字符数。对于浮点数，可以使用其他参数对小数部分进行舍入，比如，%-4.2f，其中.2指定保留了2个小数位。注意，在每行格式字符串后都需要手动加上一个换行符（\n）。

#### 实战演练

1、如果需要打印特殊字符，那么就不要将其放在双引号中，或者你可以在其之前加上一个特殊的转义字符（\）将其转义，比如：

```shell
 $echo ‘Hello world !’
 或者
 $echo “Hello world \!”
```

2、使用printf的时候我们需要手动加上换行符，比如在下面的脚本中：

```shell
 #!/bin/bash
 printf “%-5s %-10s %-4s\n” No Name Mark
 printf “%-5s %-10s %-4.2f\n” 1 Sarath 80.3456
 printf “%-5s %-10s %-4.2f\n” 2 James 90.9989
 我们会得到如下格式化的输出：
 No  Name  Mark
 1   Sarath 80.35
 2   James  91.00
```

#### 补充内容

- 使用echo和printf的命令选项时，要确保选项应该出现命令行内所有字符串之前，否则Bash会将其视为另一个字符串。
- 在默认情况下，echo会将换行符追加到输出文本的尾部。可以使用选项-n来忽略结尾的换行符。echo同样接受双引号字符串内的转义序列作为参数。如果需要使用转义序列，则采用echo -e “包含转义序列的字符串”这种形式，比如：
   echo -e “1\t2\t3”
   1 2 3

### 玩转文件描述符及重定向

#### 三个常见文件描述符

　　文件描述符是与文件输入、输出相关联的整数。它们用来跟踪已打开的文件。最常见的文件描述符是stdin、stdout和stderr。我们甚至可以将某个文件描述符的内容重定向到另一个文件描述符中。其中，文件描述符0、1以及2是系统预留的：

- 0————stdin（标准输入）
- 1————stdout（标准输出）
- 2————stderr（标准错误）

#### 输出重定向

　　就输出重定向而言，>和>>并不相同。尽管两者都可以将文本重定向到文件，但是前者会先清空文件，然后再写入内容，而后者会将内容追加到现有文件的尾部。当使用重定向操作符时，输出内容不会在终端打印，而是被导向文件。重定向操作符默认使用标准输出。如果想使用特定的文件描述符，你必须在描述符编号置于操作符之前。

\>等同于1>;对于>>来说，情况也类似（即>>等同于1>>）

处理错误时，来自stderr的输出被丢弃到文件/dev/null中。/dev/null是一个特殊的设备文件，它接收到的任何数据都会被丢弃。null设备通常 也被称为黑洞，因为凡是到这儿的数据都将一去不返。

#### 将文件内容重定向到命令

　　借助重定向，我们可以像使用stdin那样从文件中读取数据：

$ cmd < file

#### 实战演练

1、用下面的方法可以将输出文本重定向或保存到一个文件中：

```shell
$ echo “This is a sample text 1” > temp.txt # 通过截断文件的方式，将输出文本保存到文件temp.txt中。
```

2、将文本追加到目标文件中：

```shell
$ echo “This is a sample text 2” >> temp.txt
```

3、查看文件内容：

```shell
$ cat temp.txt
This is a sample text 1
This is a sample text 2
```

4、来看看标准错误以及如何对它重定向，当命令输出错误信息时，stderr信息就会被打印出来：

```shell
$ ls +
ls: cannot access +: No such file or directory
```

5、想将标准错误信息重定向到一个文件中，我们需要在重定向符前面指定标准错误的文件描述符：

```shell
ls + 2> out.txt # 标准错误的文件描述符是2
```

#### 补充内容

- 如果对stderr或stdout进行重定向，被重定向的文本会传入文件。因为文本已经被重定向到文件中，也就没剩下什么东西可以通过管道（|）传给接下来的命令，注意，这些接下来的命令是通过stdin来对前一个命令的内容进行接收的。
- 小结：文件描述符是一种用于访问文件的抽象指示器。存取文件离不开被称为“文件描述符”的特殊数字。0、1和2分别是stdin、stdout和stderr的预留描述符编号。< 操作符用于从文件中读取至stdin；> 操作符用于截断模式的文件写入；>> 操作符用于追加模式的文件写入。

### 玩转变量和环境变量

#### 变量和环境变量

　　变量是任何一种编程语言都必不可少的组成部分，用于存放各类数据。脚本语言通常不需要在使用变量之前声明其类型。只需要直接赋值就可以了。在Bash中，每一个变量的值都是字符串。无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。

　　有一些特殊的变量被shell环境和操作系统用来存储一些特别的值，这类变量就被称为环境变量。环境变量通常用于存储路径列表，这些路径用于搜索可执行文件、库文件等。例如$PATH、$LD_LIBRARY_PATH等，它们通常看起来像这样：

PATH=/usr/bin:/bin

LD_LIBRARY_PATH=/usr/lib:/lib

这意味着只要shell需要运行二进制可执行文件时，它会首先查找/usr/bin，然后是/bin。

#### 实战演练

- 对于进程来说，其运行时的环境变量可以使用下面的命令来查看：
   
   ```shell
   $ cat /proc/$PID/environ # 其中将PID设置成相关进程的进程ID
   ```
   
- 假设有一个叫做gedit的应用程序正在运行，我们可以使用pgrep命令获得gedit的进程ID：
   
   ```shell
   $ pgrep gedit
   12501
   $ cat /proc/12501/environ
   GDM_KEYBOARD_LAYOUT=us…
   ```
   
- 变量可以通过以下方式进行赋值：
   
   ```shell
   $ var=value
   $ echo $var # 或者echo ${var}
   输出如下：
   value
   ```
   
- 我们可以在printf或echo命令的双引号中引用变量值：
   
   ```shell
   #!/bin/bash
   fruit=apple
   count=5
   echo “We have $count ${fruit}(s)”
   输出如下：
   We have 5 apple(s)
   ```
   
- 环境变量是没有在当前进程中定义的，而是从父进程中继承而来的变量。export命令用来设置环境变量。至此之后，从当前shell脚本执行的任何应用程序都会继承这个变量。在默认情况下，有很多标准环境变量可供shell使用。PATH就是其中之一。通常，变量PATH包含：
   
   ```shell
   $ echo $PATH
   /home/username/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/bin
   ```
   
   在给出所要执行的命令后，shell会自动在PATH环境变量所包含的目录列表中（各目录路径之间以冒号分隔）查找相应的可执行文件。PATH通常定义在/etc/environment或/etc/profile或~/.bashrc中。如果需要在PATH中添加一条新路径，可以使用：
   
   ```shell
   export PATH=”$PATH:/home/user/bin”
   或者
   $ PATH=”$PATH:/home/user/bin”
   $ export PATH
   ```
   
- 我们也可以自定一个名为prepend()的函数，来实现添加环境变量：
   
   ```shell
   prepend() {[ -d “$2” ] && eval $1=\”$2”\$\{$1:+’:’\&&1\}\” && export $1 ; }
   可以像下面这样使用该函数：
   prepend PATH /opt/myapp/bin
   prepend LD_LIBRARY_PATH /opt/myapp/lib
   ```

#### 补充内容

- var = value不同于var=value。把var=value写成var = value是一个常见的错误，但前者是赋值操作，而后者则是相等操作。在变量名之前加上$前缀就可以打印出变量的内容。

- 可以用下面的方法来获得变量值的长度：
   
   ```shell
   $ lenth=${#var}
   ```
   
- 识别当前所使用的shell：
   
   ```shell
   $ echo $SHELL # 或者echo $0
   ```
   
- 还有一些特殊的字符可以扩展成系统参数。例如：\u可以扩展为用户名；\h可以扩展为主机名；而\w可以扩展为当前工作目录。

### 使用shell进数学运算

　　在Bash shell环境中，可以利用let、(())和[]执行基本的算术操作（只能用于整数运算）。而在进行高级操作时，expr和bc这两个工具也会非常有用。

#### 实战演练

- 可以使用普通的变量赋值方法定义数值，这时，它会被存储为字符串。然而，我们可以用一些方法使它能像数字一样进行运算：
   
   ```shell
   #!/bin/bash
   no1=4;
   no2=5;
   ```
   
- let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要在添加$：
   
   ```shell
   let result=no1+no2
   let no1++ # 自加
   let no1-- # 自减
   let no2+=6 # 简写形式
   ```
   
- 操作符[]的使用和let命令类似：
   
   ```shell
   result=$[ no1 + no2 ]
   在[]中也可以使用$前缀，比如：
   result=$[ $no1 + 5 ]
   ```
   
- 也可以使用(())，但使用(())时，变量之前需要加上$:
   
   ```shell
   result=$((no1 + 50))
   ```
   
- expr同样可以用于基本算术操作：
   
   ```shell
   result=’expr 3 + 4’
   result=$(expr $no1 + 5)
   ```
   
- bc是一个用于数学运算的高级工具，我们可以借助它执行浮点数运算并应用一些高级函数：
   
   ```shell
   echo “4 * 0.56” | bc
   2.24
   设定小数精度，在下面的例子中，参数scale=2将小数位的个数设置为2：
   echo “scale=2;3/8” | bc
   0.37
   进制转换，用bc可以将一种进制系统转换为另一种：
   #!/bin/bash
   no=100
   echo “obase=2;$no” | bc
   1100100
   no=1100100
   echo “obase=10;ibase=2;$no” | bc # ibase表示输入的进制系统，obase表示输出的进制系统。
   ```

### 函数和参数

#### 实战演练

- 我们可以创建执行特定任务的函数，也可以创建能够接受参数的函数。方法如下所示：
   
   ```shell
   定义函数：
   function fname()
   {
   }
   或者
   fname()
   {
   }
   只需要使用函数名就可以调用某个函数：
   $ fname ; # 执行函数
   参数可以传递给函数，并由脚本进行访问：
   fname arg1 arg2 ; # 传递参数
   以下是函数fname的定义，在函数fname中，包含了各种访问函数参数的方法：
   fname()
   {
    echo $1, $2; # 访问参数1和参数2
    echo “$@”;  # 以列表的方式一次性打印所有参数
    echo “$*”;  # 类似于$@，但是参数被作为单个实体
    return 0;  # 返回值
   }
   ```

#### 补充内容

- 导出函数：函数也能像环境变量一样用export导出，函数的作用域就可以扩展到子进程中：
   
   ```shell
   export -f fname
   ```
   
- 读取命令返回值（状态）：我们可以按照下面的方式获取命令或函数的返回值：
   
   ```shell
   cmd;
   echo $?;  # $?会给出命令cmd的返回值
   返回值被称为退出状态，它可用于分析命令执行成功与否。如果命令成功退出，那么退出转态为0，否则为非0.
   ```

### shell流程控制

#### 循环语句

对一系列值进行迭代时，循环非常有用。Bash提供了多种类型的循环。下面就来看看怎样使用它们：

- for循环
   
   ```shell
   for var in list; # list可以是一个字符串，也可以是一个序列
   do
    commands;    # 使用变量$var
   done
   echo {1..50}能够生成1~50的数字列表。echo {a..z}或{A..Z}或{a..h}都可以生成相应的字母列表：
   for i in {a..z}; do actions; done
   for循环也可以采用C语言中的for循环的格式。例如：
   for((i=0;i<10;i++))
   {
    commands;   # 使用环境变量$i
   }
   ```
   
- while循环
   
   ```shell
   while condition
   do
    commands;
   done
   用true作为循环条件能够产出无线循环。
   ```
   
- until循环
   
   ```shell
   在Bash环境中还可以使用一个特殊的循环until。它会一直执行循环，直到给定的条件为真：
   x=0;
   until [ $x -eq 9 ];  # 条件是[ $x -eq 9 ]
   do
    let x++; echo $x;
   done
   ```

#### 比较与测试

程序中的流程控制是由比较语句和测试语句处理的。我们可以用if、else if以及逻辑运算符进行测试，用比较运算符来比较数据项。除此之外，还有一个test命令也可以用来测试。这些命令的用法如下：

- if条件
   if condition;
   then
    commands;
   fi
   
- else if和else
   if condition;
   then
    commands;
   else if condition; then
    commands;
   else
    commands;
   fi
   
- 算术比较
   条件通常被放置在封闭的中括号中。一定要注意在[或]与操作数之间一定要有一个空格。如果忘记了这个空格，脚本就会报错，例如：
   
   ```shell
   [$var -eq 0 ] or [ $var -eq 0]
   对变量或值进行算术条件判断：
   [ $var -eq 0 ]  # 当$var等于0时，返回真
   [ $var -ne 0 ]  # 当$var为非0时，返回真
   其他重要的操作符如下所示：
   -gt: 大于
   -lt: 小于
   -ge: 大于或等于
   -le: 小于或等于
   可以按照下面的方法结合多个条件进行测试：
   [ $var1 -ne 0 -a $var2 -gt 2 ]   # 使用逻辑与-a
   [ $var1 -ne 0 -o $var2 -gt s ]   # 使用逻辑或-o
   注意：g(greater)、l(less)、e(equal)、a(and)、o(or)
   ```

#### 补充内容

- 文件系统相关测试，我们可以使用不同的条件标志测试不同的文件系统相关的属性：

  ```shell
  [ -f $file_var]: 如果给定的变量包含正常的文件路径或文件名，则返回真。
  [ -x $var ]: 如果给定的变量包含的文件可执行，则返回真。
  [ -d $var ]: 如果给定的变量包含的是目录，则返回真。
  [ -e $var ]: 如果给定的变量包含的文件存在，则返回真。
  [ -c $var ]: 如果给定的变量包含的是一个字符设备文件的路径，则返回真。
  [ -b $var ]: 如果给定的变量包含的是一个块设备文件的路径，则返回真。
  [ -w $var ]: 如果给定的变量包含的文件可写，则返回真。
  [ -r $var ]: 如果给定的变量包含的文件可读，则返回真。
  [ -L $var ]: 如果给定的变量包含的是一个符号链接，则返回真。
  ```

- 字符串比较
   使用字符串比较时，最好用双括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。可以用下面的方法检查两个字符串是否相同：
   
   ```shell
   [[ $str1 = $str2 ]]
   [[ $str1 == $str2 ]]
   [[ $str1 != $str2 ]]
   [[ -z $str1 ]]: 如果str1包含的是空字符串，则返回真。
   [[ -n $str1 ]]: 如果str1包含的是非空字符串，则返回真。
   使用逻辑运算符&&和||能够很容易地将多个条件组合起来：
   if [[ -n $str1 ]] && [[ -z $str2 ]];
   then
  commonds;
   fi
   ```
   
- test命令可以用来执行条件检测。用test可以避免使用过多的括号。之前讲过的[]中的测试条件同样可以用于test命令：
   
   ```shell
   if [ $var -eq 0 ]; then echo “True”; fi
   也可以写成：
   if test $var -eq 0; then echo “True”; fi
   ```

### 调试脚本

#### 实战演练

- 我们可以利用Bash内建的调试工具，或者按照易于调试的方式编写脚本，方法如下所示：
   使用选项-x，启用shell脚本的跟踪调试功能：
   
   ```shell
   $ bash -x script.sh
   运行带有-x标志的脚本可以打印出所执行的每一行命令以及当前状态。注意，你也可以使用sh -x script。
   ```
   
- 使用set -x和set +x对脚本进行部分调试。例如：
   
   ```shell
   #!/bin/bash
   #文件名：debug.sh
   for i in {1..6};
   do
    set -x
    echo $i
    set +x
   done
   在上面的脚本中，只会打印echo $i的调试信息，因为使用了-x和+x对调试区域进行了限制。
   ```

#### 补充内容

- -x标志将脚本中执行过的每一行都输出到了stdout。不过，我们也可能只关注脚本某些部分的命令及参数的打印输出。针对这种情况，可以在脚本中使用set builtin来启用或禁止调试打印：
   
   ```shell
   set -x: 在执行时显示参数和命令
   set +x: 禁止调试
   set -v: 当命令进行读取时显示输入
   set +v: 禁止打印输入
   ```
   
- shebang的妙用：
   把shebang从#!/bin/bash改成#!/bin/bash -xv，这样一来，不用任何其他选项就可以启用调试功能了。

